name: Organization Public License Scan

on:
  workflow_dispatch:
    inputs:
      organization:
        description: 'GitHub organization name (e.g., "my-org")'
        required: true
        type: string
      github_token: # Made optional
        description: 'Optional GitHub PAT for higher rate limits (if not provided, uses unauthenticated or GITHUB_TOKEN)'
        required: false
        type: string
      output_filename:
        description: 'Name of the output JSON file'
        required: false
        default: 'organization_public_licenses.json'
        type: string
  schedule:
    # Example: Run every Monday at 2 AM UTC
    - cron: '0 2 * * 1'

jobs:
  scan_licenses:
    runs-on: ubuntu-latest
    permissions:
      contents: read # For checkout
      # No specific permissions needed for GITHUB_TOKEN to list/clone public repos from other orgs

    steps:
      - name: Checkout code (optional)
        uses: actions/checkout@v4

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.1'
          bundler-cache: true

      - name: Install licensee
        run: gem install licensee

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Install/Ensure GitHub CLI
        run: |
          if ! type -p gh &>/dev/null; then
            echo "GitHub CLI not found, installing..."
            sudo apt-get update
            sudo apt-get install -y curl
            curl -fsSL https://cli.github.com/packages/githubcli-archive-keyring.gpg | sudo dd of=/usr/share/keyrings/githubcli-archive-keyring.gpg \
            && sudo chmod go+r /usr/share/keyrings/githubcli-archive-keyring.gpg \
            && echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/githubcli-archive-keyring.gpg] https://cli.github.com/packages stable main" | sudo tee /etc/apt/sources.list.d/github-cli.list > /dev/null \
            && sudo apt update \
            && sudo apt install -y gh
          else
            echo "GitHub CLI already installed."
          fi
          gh --version

      - name: Prepare environment variables
        id: prep_env
        run: |
          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "ORGANIZATION_TO_SCAN=${{ secrets.ORG_NAME_FOR_SCAN }}" >> $GITHUB_ENV
            # For scheduled runs, use GITHUB_TOKEN for better rate limits than unauthenticated.
            # A dedicated PAT (secrets.ORG_REPO_SCAN_PAT) could still be used here if preferred for max rate limits.
            echo "GH_TOKEN_FOR_SCAN=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_ENV
            echo "OUTPUT_FILENAME_TO_USE=organization_public_licenses_scheduled.json" >> $GITHUB_ENV
          else # workflow_dispatch
            echo "ORGANIZATION_TO_SCAN=${{ inputs.organization }}" >> $GITHUB_ENV
            echo "GH_TOKEN_FOR_SCAN=${{ inputs.github_token }}" >> $GITHUB_ENV # Can be empty
            echo "OUTPUT_FILENAME_TO_USE=${{ inputs.output_filename }}" >> $GITHUB_ENV
          fi

      - name: Authenticate GitHub CLI and Git (if token provided)
        # This GH_TOKEN is from the prep_env step
        env:
          GH_TOKEN: ${{ env.GH_TOKEN_FOR_SCAN }}
        run: |
          if [ -z "$ORGANIZATION_TO_SCAN" ]; then
            echo "Error: Organization name (ORG_NAME_FOR_SCAN secret or organization input) is not set."
            exit 1
          fi
          if [ -n "$GH_TOKEN" ]; then
            echo "Authenticating GitHub CLI and Git with provided token."
            echo "$GH_TOKEN" | gh auth login --with-token
            gh auth setup-git
          else
            echo "No GitHub token provided. Proceeding with unauthenticated access (lower rate limits)."
            # Ensure git doesn't try to prompt for credentials for public repos
            git config --global credential.helper ''
          fi

      - name: Scan public repositories and generate report
        env:
          # ORGANIZATION_TO_SCAN, OUTPUT_FILENAME_TO_USE are inherited from GITHUB_ENV
          # GH_TOKEN (for gh cli and git clone) is implicitly used by gh auth setup-git if login occurred
        run: |
          set -e
          set -o pipefail

          echo "Scanning public repositories in organization: $ORGANIZATION_TO_SCAN"
          echo "Output file will be: $OUTPUT_FILENAME_TO_USE"

          TEMP_LICENSE_FILE="license_lines.temp.jsonl"
          FINAL_OUTPUT_FILE="$OUTPUT_FILENAME_TO_USE"
          > "$TEMP_LICENSE_FILE"

          echo "Fetching public repository list for $ORGANIZATION_TO_SCAN..."
          # Added --visibility public
          # If GH_TOKEN was provided and auth succeeded, gh uses it. Otherwise, unauthenticated.
          repo_names_json=$(gh repo list "$ORGANIZATION_TO_SCAN" --visibility public --limit 2000 --json name --jq '.[].name')

          if [ -z "$repo_names_json" ]; then
            echo "No public repositories found in organization $ORGANIZATION_TO_SCAN or failed to list them."
            echo "[]" > "$FINAL_OUTPUT_FILE"
            exit 0
          fi

          MAX_RETRIES=3
          RETRY_DELAY_SECONDS=10

          for repo_name in $repo_names_json; do
            repo_full_name="$ORGANIZATION_TO_SCAN/$repo_name"
            echo "-----------------------------------------------------"
            echo "Processing repository: $repo_full_name"
            CLONE_DIR=$(mktemp -d -t "repo_${repo_name}_XXXXXX")
            echo "Cloning to temporary directory: $CLONE_DIR"

            current_attempt=1
            processed_successfully=false

            while [ $current_attempt -le $MAX_RETRIES ]; do
              echo "Attempt $current_attempt/$MAX_RETRIES to clone and analyze $repo_full_name..."

              # GIT_TERMINAL_PROMPT=0 is good practice.
              # For public repos, authentication isn't strictly needed for cloning,
              # but if gh auth setup-git ran, git will use the token (good for rate limits).
              if GIT_TERMINAL_PROMPT=0 git clone --depth 1 --quiet "https://github.com/$repo_full_name.git" "$CLONE_DIR"; then
                echo "Clone successful."
                cd "$CLONE_DIR"
                license_output=$(licensee detect --json . 2>/dev/null || echo "LICENSEE_CLI_ERROR")
                cd ..

                if [[ "$license_output" == "LICENSEE_CLI_ERROR" ]]; then
                    license_id="LICENSEE_CLI_ERROR"
                elif [[ "$license_output" == "null" ]] || [[ -z "$license_output" ]]; then
                    license_id="NONE_FOUND"
                else
                    license_id_raw=$(echo "$license_output" | jq -r '.matched_license.spdx_id // .matched_license.name')
                    if [[ "$license_id_raw" == "null" ]] || [[ -z "$license_id_raw" ]]; then
                        license_id="UNKNOWN_OR_NO_MATCH"
                    else
                        license_id="$license_id_raw"
                    fi
                fi
                echo "License for $repo_full_name: $license_id"
                processed_successfully=true
                break
              else
                echo "Clone failed for $repo_full_name (attempt $current_attempt)."
                if [ $current_attempt -lt $MAX_RETRIES ]; then
                  echo "Retrying in $RETRY_DELAY_SECONDS seconds..."
                  sleep $RETRY_DELAY_SECONDS
                else
                  echo "Max retries reached for $repo_full_name. Marking as clone error."
                  license_id="ERROR_CLONING"
                fi
              fi
              current_attempt=$((current_attempt + 1))
            done

            jq -n --arg repo_name "$repo_name" --arg license_id "$license_id" \
              '{ "repository_name": $repo_name, "license": $license_id }' >> "$TEMP_LICENSE_FILE"
            rm -rf "$CLONE_DIR"
            echo "Cleaned up $CLONE_DIR."
          done < <(echo "$repo_names_json")

          jq -s '.' "$TEMP_LICENSE_FILE" > "$FINAL_OUTPUT_FILE"
          rm "$TEMP_LICENSE_FILE"

          echo "-----------------------------------------------------"
          echo "Public license report generated: $FINAL_OUTPUT_FILE"
          cat "$FINAL_OUTPUT_FILE"

      - name: Upload license report
        uses: actions/upload-artifact@v4
        with:
          name: public-license-report
          path: ${{ env.OUTPUT_FILENAME_TO_USE }}
