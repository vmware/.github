name: Org — Manage CLA Stubs (requires_cla)

on:
  workflow_dispatch:
    inputs:
      org:
        description: "Organization login (defaults to caller's org)"
        required: false
      reusable_ref:
        description: "Ref for reusable CLA workflow (e.g., main)"
        required: false
        default: "main"
      allowlist_branch:
        description: "Branch in .github with allowlist"
        required: false
        default: "cla-config"
      allowlist_path:
        description: "Path to YAML allowlist"
        required: false
        default: "cla/allowlist.yml"
      sign_phrase:
        description: "Exact phrase for signing via comment"
        required: false
        default: "I have read the CLA Document and I hereby sign the CLA"
      secret_name:
        description: "Repo secret name forwarded to reusable workflow"
        required: false
        default: "CLA_ASSISTANT_PAT"
      include_repos:
        description: "Comma-separated glob(s) to include (optional)"
        required: false
        default: ""
      exclude_repos:
        description: "Comma-separated glob(s) to exclude (optional)"
        required: false
        default: ""

permissions:
  contents: write
  actions: read

concurrency:
  group: ${{ github.workflow }}-${{ github.run_id }}
  cancel-in-progress: false

jobs:
  manage:
    name: Discover & reconcile stubs via requires_cla.py
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      ORG: ${{ inputs.org || github.repository_owner }}
      REUSABLE_REF: ${{ inputs.reusable_ref }}
      ALLOWLIST_BRANCH: ${{ inputs.allowlist_branch }}
      ALLOWLIST_PATH: ${{ inputs.allowlist_path }}
      SIGN_PHRASE: ${{ inputs.sign_phrase }}
      SECRET_NAME: ${{ inputs.secret_name }}
      ORG_PAT: ${{ secrets.ORG_PAT }}

      # Use repo/org Variables (Settings → Variables) as fallbacks if inputs are blank
      INCLUDE_REPOS: ${{ inputs.include_repos != '' && inputs.include_repos || (vars.INCLUDE_REPOS || '') }}
      EXCLUDE_REPOS: ${{ inputs.exclude_repos != '' && inputs.exclude_repos || (vars.EXCLUDE_REPOS || '') }}

    steps:
      - name: Plan
        run: |
          echo "Org: ${ORG}"
          echo "Reusable ref: ${REUSABLE_REF}"
          echo "Allowlist: ${ALLOWLIST_BRANCH}:${ALLOWLIST_PATH}"
          echo "Sign phrase: ${SIGN_PHRASE}"
          echo "Secret name: ${SECRET_NAME}"
          echo "Include globs: ${INCLUDE_REPOS}"
          echo "Exclude globs: ${EXCLUDE_REPOS}"

      - name: Checkout .github (stage manager & helper modules)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/.github
          path: .github-admin
          persist-credentials: false
          fetch-depth: 1

      - name: Ensure helper modules exist
        run: |
          ls -la .github-admin/scripts || true
          test -f .github-admin/scripts/requires_cla.py || echo "WARNING: requires_cla.py not found in .github-admin/scripts"

      # Write the manager Python script WITHOUT heredoc (use Node fs)
      - name: Write manager script (refactored)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const dir = path.join(process.cwd(), '.github-admin', 'run');
            fs.mkdirSync(dir, { recursive: true });
            const file = path.join(dir, 'check_and_install_stub.py');
            const py = String.raw`#!/usr/bin/env python3
            # -*- coding: utf-8 -*-
            """
            Manager (requires_cla edition) — public repos only

            - Lists org repos (public, non-archived/non-disabled)
            - Applies include/exclude globs (from inputs or env)
            - Calls requires_cla.requires_CLA("<org>/<repo>", token)
            - Ensures trigger stub present when True/None (fail-safe), absent when False
            - Emits: REPO=<name> STATUS=<...> DECISION=<True|False|None> MSG=<text>
            """

            from __future__ import annotations

            import argparse
            import base64
            import fnmatch
            import json
            import os
            import re
            import sys
            import urllib.request
            from typing import Dict, List, Optional, Tuple

            TARGET_STUB_VERSION = "7"
            STUB_PATH = ".github/workflows/cla-check-trigger.yml"

            # Default excludes (special GitHub repos, admin/security):
            DEFAULT_EXCLUDES = [".github", ".github-*", "security", "security-*", "admin", "admin-*"]

            # Module import path candidates
            CANDIDATE_MODULE_DIRS = [
                os.path.join(os.getcwd(), ".github-admin", "scripts"),
                os.path.join(os.getcwd(), ".github", "scripts"),
                os.getcwd(),
            ]
            for p in CANDIDATE_MODULE_DIRS:
                if os.path.isdir(p) and p not in sys.path:
                    sys.path.insert(0, p)

            try:
                import requires_cla  # decision module
            except Exception as e:
                print(f"ERROR: Could not import requires_cla.py: {e}", file=sys.stderr)
                sys.exit(2)

            def gh_api(url: str, token: str, method: str = "GET", body: bytes | None = None, accept: str = "application/vnd.github+json") -> Dict:
                req = urllib.request.Request(url, method=method)
                req.add_header("Authorization", f"Bearer {token}")
                req.add_header("Accept", accept)
                if body is not None:
                    req.add_header("Content-Type", "application/json")
                    req.data = body
                with urllib.request.urlopen(req) as r:
                    data = r.read()
                    return json.loads(data.decode()) if data else {}

            def list_public_repos(org: str, token: str) -> List[Dict]:
                results, page = [], 1
                while True:
                    url = f"https://api.github.com/orgs/{org}/repos?per_page=100&page={page}&type=public&sort=full_name&direction=asc"
                    data = gh_api(url, token)
                    if not isinstance(data, list) or not data:
                        break
                    results.extend(data); page += 1
                return [r for r in results if not (r.get("archived") or r.get("disabled")) and r.get("private") is False]

            def get_default_branch(owner: str, repo: str, token: str) -> str:
                data = gh_api(f"https://api.github.com/repos/{owner}/{repo}", token)
                return data.get("default_branch", "main")

            def get_file(owner: str, repo: str, path: str, ref: str, token: str) -> Tuple[Optional[str], Optional[str]]:
                try:
                    data = gh_api(f"https://api.github.com/repos/{owner}/{repo}/contents/{path}?ref={ref}", token)
                    if isinstance(data, dict) and data.get("content"):
                        content = base64.b64decode(data["content"]).decode()
                        return content, data.get("sha")
                except Exception:
                    pass
                return None, None

            def put_file(owner: str, repo: str, path: str, ref: str, token: str, content: str, sha: str | None, message: str) -> Dict:
                body = {"message": message, "content": base64.b64encode(content.encode()).decode(), "branch": ref}
                if sha: body["sha"] = sha
                return gh_api(f"https://api.github.com/repos/{owner}/{repo}/contents/{path}", token, method="PUT", body=json.dumps(body).encode())

            def delete_file(owner: str, repo: str, path: str, ref: str, token: str, sha: str, message: str) -> Dict:
                body = {"message": message, "sha": sha, "branch": ref}
                return gh_api(f"https://api.github.com/repos/{owner}/{repo}/contents/{path}", token, method="DELETE", body=json.dumps(body).encode())

            STUB_TEMPLATE = """# Auto-managed; DO NOT EDIT MANUALLY
            # Stub Version: {stub_version}
            name: CLA — Trigger Stub

            on:
              pull_request_target:
                types: [opened, synchronize, reopened]
              issue_comment:
                types: [created]

            permissions:
              contents: read
              pull-requests: write
              issues: write
              statuses: write
              actions: read

            concurrency:
              group: ${{{{ github.workflow }}}}-${{{{ github.event.pull_request.number || github.run_id }}}}
              cancel-in-progress: true

            jobs:
              guard:
                name: Gate & Dispatch
                runs-on: ubuntu-latest
                if: >
                  (github.event_name == 'pull_request_target') ||
                  (github.event_name == 'issue_comment' && github.event.issue.pull_request)

                steps:
                  - name: Short-circuit for org members (fast path)
                    id: member
                    uses: actions/github-script@v7
                    with:
                      github-token: ${{{{ secrets.{secret_name} }}}}
                      script: |
                        let isMember = false;
                        try {{
                          await github.rest.orgs.checkMembershipForUser({{ org: context.repo.owner, username: context.payload.sender.login }});
                          isMember = true;
                        }} catch {{}}
                        core.setOutput('is_member', isMember ? 'true' : 'false');

                  - name: Skip if org member
                    if: ${{{{ steps.member.outputs.is_member == 'true' }}}}
                    run: echo "Org member — skipping CLA."

                  - name: Call reusable CLA checker
                    if: ${{{{ steps.member.outputs.is_member != 'true' }}}}
                    uses: ${{{{ github.repository_owner }}}}/.github/.github/workflows/reusable-cla-check.yml@{reusable_ref}
                    secrets:
                      CONTRIBUTOR_ASSISTANT_PAT: ${{{{ secrets.{secret_name} }}}}
                    with:
                      allowlist_branch: "{allowlist_branch}"
                      allowlist_path: "{allowlist_path}"
                      sign_comment_exact: "{sign_phrase}"
            """

            def ensure_stub(owner: str, repo: str, token: str, default_branch: str,
                            reusable_ref: str, allowlist_branch: str, allowlist_path: str,
                            sign_phrase: str, secret_name: str) -> str:
                desired = STUB_TEMPLATE.format(
                    stub_version=TARGET_STUB_VERSION,
                    reusable_ref=reusable_ref,
                    allowlist_branch=allowlist_branch,
                    allowlist_path=allowlist_path,
                    sign_phrase=sign_phrase.replace('"','\\"'),
                    secret_name=secret_name
                )
                existing, sha = get_file(owner, repo, STUB_PATH, default_branch, token)
                if existing:
                    m = re.search(r"Stub Version:\\s*(\\d+)", existing)
                    cur_ver = m.group(1) if m else "0"
                    needs_update = (cur_ver != TARGET_STUB_VERSION) or (existing.strip() != desired.strip())
                    if needs_update:
                        put_file(owner, repo, STUB_PATH, default_branch, token, desired, sha, f"chore(cla): ensure trigger stub v{TARGET_STUB_VERSION}")
                        return "stub_created_or_updated"
                    return "stub_ok"
                else:
                    put_file(owner, repo, STUB_PATH, default_branch, token, desired, None, f"chore(cla): add trigger stub v{TARGET_STUB_VERSION}")
                    return "stub_created_or_updated"

            def globs_to_list(val: str | None) -> List[str]:
                return [g.strip() for g in (val or "").split(",") if g.strip()]

            def allowed_by_globs(name: str, includes: List[str], excludes: List[str]) -> bool:
                if includes:
                    if not any(fnmatch.fnmatch(name, pat) for pat in includes):
                        return False
                for pat in excludes:
                    if fnmatch.fnmatch(name, pat):
                        return False
                return True

            def parse_args() -> argparse.Namespace:
                ap = argparse.ArgumentParser()
                ap.add_argument("--org", required=True)
                ap.add_argument("--reusable-ref", required=True)
                ap.add_argument("--allowlist-branch", required=True)
                ap.add_argument("--allowlist-path", required=True)
                ap.add_argument("--sign-phrase", required=True)
                ap.add_argument("--secret-name", default="CLA_ASSISTANT_PAT")
                ap.add_argument("--include-repos", default=os.environ.get("INCLUDE_REPOS",""))
                ap.add_argument("--exclude-repos", default=os.environ.get("EXCLUDE_REPOS",""))
                return ap.parse_args()

            def main() -> None:
                args = parse_args()
                token = os.environ.get("GITHUB_TOKEN") or os.environ.get("ORG_PAT")
                if not token:
                    print("ERROR: GITHUB_TOKEN/ORG_PAT not set", file=sys.stderr); sys.exit(2)

                includes = globs_to_list(args.include_repos)
                excludes = DEFAULT_EXCLUDES + globs_to_list(args.exclude_repos)

                repos = list_public_repos(args.org, token)

                for r in repos:
                    name = r.get("name") or ""
                    if not name:
                        print("REPO=? STATUS=error DECISION=None MSG=missing repo name", file=sys.stderr)
                        continue

                    if not allowed_by_globs(name, includes, excludes):
                        print(f"REPO={name} STATUS=skipped_filtered DECISION=None MSG=Filtered by include/exclude")
                        continue

                    full = f"{args.org}/{name}"
                    try:
                        decision: Optional[bool] = None
                        try:
                            decision = requires_cla.requires_CLA(full, token=token)
                        except Exception:
                            decision = None  # fail-safe

                        requires = True if decision is None else bool(decision)

                        default_branch = get_default_branch(args.org, name, token)
                        existing, sha = get_file(args.org, name, STUB_PATH, default_branch, token)

                        if requires:
                            status = ensure_stub(args.org, name, token, default_branch,
                                                 args.reusable_ref, args.allowlist_branch, args.allowlist_path,
                                                 args.sign_phrase, args.secret_name)
                            print(f"REPO={name} STATUS={status} DECISION={requires} MSG=CLA required")
                        else:
                            if existing and sha:
                                delete_file(args.org, name, STUB_PATH, default_branch, token, sha,
                                            "chore(cla): remove trigger stub (CLA not required)")
                                print(f"REPO={name} STATUS=stub_removed_not_required DECISION={requires} MSG=Removed stub")
                            else:
                                print(f"REPO={name} STATUS=skipped_not_required DECISION={requires} MSG=No stub (as expected)")
                    except Exception as e:
                        print(f"REPO={name} STATUS=error DECISION=None MSG={e}", file=sys.stderr)

            if __name__ == "__main__":
                main()
            `;
            fs.writeFileSync(file, py);
            fs.chmodSync(file, 0o755);

      - name: Ensure Python available
        run: python3 -V

      - name: Run manager (requires_cla)
        id: runmgr
        env:
          GITHUB_TOKEN: ${{ env.ORG_PAT }}
        run: |
          set -o pipefail
          python3 .github-admin/run/check_and_install_stub.py \
            --org "${ORG}" \
            --reusable-ref "${REUSABLE_REF}" \
            --allowlist-branch "${ALLOWLIST_BRANCH}" \
            --allowlist-path "${ALLOWLIST_PATH}" \
            --sign-phrase "${SIGN_PHRASE}" \
            --secret-name "${SECRET_NAME}" \
            --include-repos "${INCLUDE_REPOS}" \
            --exclude-repos "${EXCLUDE_REPOS}" \
          2>&1 | tee manager-results.log

      - name: Summarize reconciliation in job summary
        run: |
          python3 - <<'PY'
          import os, re
          from collections import Counter
          rows = []
          with open('manager-results.log','r',encoding='utf-8',errors='ignore') as f:
              for line in f:
                  m = re.search(r'REPO=([^ ]+)\s+STATUS=([^ ]+)\s+DECISION=([^ ]+)\s+MSG=(.*)', line.strip())
                  if m: rows.append(m.groups())
          counts = Counter(r[1] for r in rows)
          with open(os.environ['GITHUB_STEP_SUMMARY'], 'a', encoding='utf-8') as out:
              out.write("## CLA Stub Reconciliation — Summary (requires_cla)\n\n")
              if counts:
                  out.write("**Counts by status:** " + ", ".join(f"`{k}`={v}" for k,v in counts.items()) + "\n\n")
              else:
                  out.write("_No reconciliation rows parsed; check raw log below._\n\n")
              out.write("| Repo | Status | RequiresCLA | Message |\n")
              out.write("|---|---|---|---|\n")
              for repo, status, decision, msg in rows:
                  out.write(f"| `{repo}` | `{status}` | `{decision}` | {msg} |\n")
          PY

      - name: Upload raw results artifact
        uses: actions/upload-artifact@v4
        with:
          name: manager-results
          path: manager-results.log
          if-no-files-found: warn
