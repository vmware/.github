name: Reusable — CLA Check

on:
  workflow_call:
    inputs:
      cla_document_url:
        description: "URL to the CLA document"
        type: string
        default: https://raw.githubusercontent.com/${{ github.repository_owner }}/.github/main/CLA.md
      signature_file_path:
        description: "Path to signatures file in .github"
        type: string
        default: signatures/CLA.json
      signature_branch:
        description: "Branch in .github where signatures are stored"
        type: string
        default: main
      allowlist_branch:
        description: "Branch in .github with allowlist config"
        type: string
        default: cla-config
      allowlist_path:
        description: "YAML allowlist path in .github"
        type: string
        default: cla/allowlist.yml
      sign_comment_exact:
        description: 'Exact phrase required to sign via comment'
        type: string
        default: 'I have read the CLA Document and I hereby sign the CLA'
    secrets:
      CONTRIBUTOR_ASSISTANT_PAT:
        required: true

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write
  actions: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

jobs:
  cla:
    name: CLA gate
    # Debounce: always run for PR events; for issue_comment only if it contains the exact sign phrase
    if: >
      ${{
        github.event_name == 'pull_request_target' ||
        (github.event_name == 'issue_comment' &&
         github.event.issue.pull_request &&
         contains(github.event.comment.body, inputs.sign_comment_exact))
      }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      ORG: ${{ github.repository_owner }}
      REPO: ${{ github.event.repository.name }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      # Preflight clarifies whether the PAT can access org .github and the allowlist branch/path.
      - name: "Preflight: verify token can reach .github and branch exists"
        shell: bash
        env:
          ORG: ${{ github.repository_owner }}
          BRANCH: ${{ inputs.allowlist_branch }}
          PAT: ${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}
        run: |
          set -euo pipefail
          api() { curl -sS -H "Authorization: Bearer ${PAT}" -H "Accept: application/vnd.github+json" "$1"; }
          api_code() { curl -sS -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${PAT}" -H "Accept: application/vnd.github+json" "$1"; }
          api_body_code() { 
            local url="$1"
            local out="$(mktemp)"
            local code
            code="$(curl -sS -o "$out" -w "%{http_code}" -H "Authorization: Bearer ${PAT}" -H "Accept: application/vnd.github+json" "$url")"
            printf "%s\n" "$out"
            printf "%s\n" "$code"
          }

          echo "Checking repo visibility and token access to ${ORG}/.github"
          out_and_code=($(api_body_code "https://api.github.com/repos/${ORG}/.github"))
          OUT_FILE="${out_and_code[0]}"
          CODE="${out_and_code[1]}"
          echo "GET /repos/${ORG}/.github -> HTTP ${CODE}"
          if [ "${CODE}" = "403" ]; then
            echo "::error::403 from /repos: token lacks access or SSO not authorized for org '${ORG}'."
            cat "${OUT_FILE}" || true
            exit 2
          elif [ "${CODE}" = "404" ]; then
            echo "::error::Repo '${ORG}/.github' not found (private? wrong org? different name?)."
            exit 2
          fi

          echo "Checking branch '${BRANCH}'"
          CODE="$(api_code "https://api.github.com/repos/${ORG}/.github/git/refs/heads/${BRANCH}")"
          echo "GET /git/refs/heads/${BRANCH} -> HTTP ${CODE}"
          if [ "${CODE}" = "404" ]; then
            echo "::error::Branch '${BRANCH}' does not exist in ${ORG}/.github. Create it or change inputs.allowlist_branch."
            curl -sS -H "Authorization: Bearer ${PAT}" -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${ORG}/.github/branches?per_page=100" | sed -n '1,200p' || true
            exit 3
          fi

          echo "Checking allowlist file path '${{ inputs.allowlist_path }}'"
          CODE="$(api_code "https://api.github.com/repos/${ORG}/.github/contents/${{ inputs.allowlist_path }}?ref=${BRANCH}")"
          echo "GET /contents/${{ inputs.allowlist_path }}?ref=${BRANCH} -> HTTP ${CODE}"
          if [ "${CODE}" = "404" ]; then
            echo "::error::Allowlist not found at that path/branch."
            exit 4
          fi

          echo "Preflight OK."

      - name: Resolve GH_TOKEN (prefer PAT, fallback to GITHUB_TOKEN)
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}" ]; then
            echo "GH_TOKEN=${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}" >> "$GITHUB_ENV"
            echo "Using CONTRIBUTOR_ASSISTANT_PAT for GitHub API calls."
          else
            echo "GH_TOKEN=${{ secrets.GITHUB_TOKEN }}" >> "$GITHUB_ENV"
            echo "Falling back to GITHUB_TOKEN for GitHub API calls."
          fi

      # Trusted checkout — ONLY the org's .github repo to read allowlist
      - name: Checkout .github (allowlist)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/.github
          ref: ${{ inputs.allowlist_branch }}
          token: ${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}
          path: .github-central
          fetch-depth: 1
          persist-credentials: false
          
      - name: Locate license policy scripts
        id: find_scripts
        shell: bash
        run: |
          set -euo pipefail
          ROOT=".github-central"
          # Search common locations; adjust/add paths if your repo uses a different layout
          CANDIDATES=$(printf "%s\n" \
            "$ROOT/scripts" \
            "$ROOT/tools" \
            "$ROOT/cla" \
            "$ROOT" \
          )
          hit=""
          for d in $CANDIDATES; do
            if [ -f "$d/requires_cla.py" ] && [ -f "$d/license_detector.py" ] && [ -f "$d/detect_org_repo_licenses.py" ]; then
              hit="$d"; break
            fi
          done
          if [ -z "$hit" ]; then
            echo "::error::Could not find requires_cla.py + license_detector.py + detect_org_repo_licenses.py under .github-central"
            exit 2
          fi
          echo "dir=$hit" >> "$GITHUB_OUTPUT"
          echo "Found policy scripts in: $hit"

      - name: Setup Python (for policy scripts)
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Determine enforcement from license policy (requires_cla.py)
        id: policy
        shell: bash
        env:
          ORG:  ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
        run: |
          set -euo pipefail
          cd "${{ steps.find_scripts.outputs.dir }}"

          run_and_capture() {
            set +e
            OUT="$("$@")"; EC=$?
            set -e
            printf "%s\n" "$OUT"
            return $EC
          }

          # Try: requires_cla.py --org ORG --repo REPO
          RAW="$(run_and_capture python requires_cla.py --org "$ORG" --repo "$REPO" 2>/dev/null || true)"
          EC=$?
          if [ $EC -ne 0 ] || [ -z "$RAW" ]; then
            # Try: requires_cla.py ORG/REPO
            RAW="$(run_and_capture python requires_cla.py "$ORG/$REPO" 2>/dev/null || true)"
            EC=$?
          fi

          # Interpret result:
          ENFORCE=""
          # 1) JSON like {"requires_cla": true}
          if printf "%s" "$RAW" | grep -qi '"requires_cla"\s*:\s*true'; then ENFORCE="true"; fi
          if printf "%s" "$RAW" | grep -qi '"requires_cla"\s*:\s*false'; then ENFORCE="false"; fi
          # 2) Plain boolean
          if [ -z "$ENFORCE" ]; then
            case "$(printf "%s" "$RAW" | tr 'A-Z' 'a-z' | tr -d '[:space:]')" in
              true) ENFORCE="true" ;;
              false) ENFORCE="false" ;;
            esac
          fi
          # 3) Exit code convention (0=enforce, 1=do not enforce) — if the tool uses that
          if [ -z "$ENFORCE" ]; then
            if [ $EC -eq 0 ]; then ENFORCE="true"; else ENFORCE="false"; fi
          fi

          if [ -z "$ENFORCE" ]; then
            echo "::warning::Could not interpret requires_cla.py output; defaulting to enforce=true"
            ENFORCE="true"
          fi

          echo "enforce=$ENFORCE" >> "$GITHUB_OUTPUT"
          echo "license_policy_enforce=$ENFORCE"

      - name: Debug checkout
        shell: bash
        run: |
          set -euxo pipefail
          git --version
          echo "Workspace: $GITHUB_WORKSPACE"
          echo "Listing .github-central:"
          ls -la .github-central
          echo "Expected allowlist: .github-central/${{ inputs.allowlist_path }}"
          if [ ! -f ".github-central/${{ inputs.allowlist_path }}" ]; then
            echo "::error::Allowlist not found at .github-central/${{ inputs.allowlist_path }}"
            exit 2
          fi

      - name: Skip — permissive by license policy
        if: ${{ steps.policy.outputs.enforce != 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            core.info('✅ CLA not required (permissive license policy)');

      - name: Install yq (YAML CLI)
        shell: bash
        run: |
          set -euo pipefail
          YQ_VER=v4.44.3
          curl -sSL -o /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VER}/yq_linux_amd64"
          chmod +x /usr/local/bin/yq
          yq --version

      - name: Compute allowlisted/member
        id: allow
        uses: actions/github-script@v7
        env:
          ALLOWLIST_PATH: ${{ inputs.allowlist_path }}
          SIGN_PHRASE: ${{ inputs.sign_comment_exact }}
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const { execSync } = require('node:child_process');
            const path = require('node:path');

            const allowPath = path.join(process.env.GITHUB_WORKSPACE, '.github-central', process.env.ALLOWLIST_PATH);
            let cfg = {};
            try {
              const json = execSync(`yq -o=json '${allowPath}'`, { stdio: ['ignore','pipe','pipe'] }).toString();
              cfg = JSON.parse(json) || {};
            } catch (e) {
              core.warning(`Allowlist not found/parse error at ${allowPath}: ${e}`);
            }

            const actor = context.payload.sender?.login;
            const org = context.repo.owner;
            const nowIso = new Date().toISOString();
            const asSet = xs => new Set((xs || []).map(s => String(s).toLowerCase()));
            const inSet = (set, s) => set.has(String(s || '').toLowerCase());

            let isMember = false;
            try { await github.rest.orgs.checkMembershipForUser({ org, username: actor }); isMember = true; } catch {}

            const botSet = asSet(cfg.bots), userSet = asSet(cfg.users);
            let allow = inSet(botSet, actor) || inSet(userSet, actor);
            let reason = allow ? 'explicit user/bot' : '';

            // --- DCO on permissive repos ---
            // Read optional DCO policy from allowlist:
            //   dco_on_permissive: "off" | "external_only" | "all"
            // Defaults to "off" if absent.
            const dcoMode = (cfg?.dco_on_permissive || 'off').toLowerCase(); // off | external_only | all
            
            // We already computed isMember above. If you don't have it, derive it here:
            // let isMember = false; try { await github.rest.orgs.checkMembershipForUser({ org, username: actor }); isMember = true; } catch {}
            
            let needDco = false;
            if (dcoMode === 'all') {
              needDco = true;
            } else if (dcoMode === 'external_only') {
              needDco = !isMember;
            }
            // If already allowlisted (users/bots/teams/temp/comment-sign), DCO not needed.
            if (allow) needDco = false; // allowlisted → no DCO
            
            // Publish for downstream if/conditions
            core.setOutput('need_dco', needDco ? 'true' : 'false');

            // Bridge: only the earlier license-policy step decides enforcement.
            // Do NOT return here; the separate "Skip — permissive by license policy" step already exits early.
            const policyEnforce = '${{ steps.policy.outputs.enforce }}' === 'true';
            core.setOutput('policy_enforce', policyEnforce ? 'true' : 'false');
 
            if (!allow && Array.isArray(cfg.teams) && cfg.teams.length) {
              try {
                const { data: teams } = await github.rest.teams.listForUserInOrg({ org, username: actor });
                const desired = asSet(cfg.teams.map(t => t.includes('/') ? t : `${org}/${t}`));
                allow = teams.some(t => desired.has(`${t.organization.login}/${t.slug}`.toLowerCase()));
                if (allow) reason = 'team';
              } catch (e) { core.warning(`Team lookup failed: ${e}`); }
            }

            if (!allow && cfg.org_members === true && isMember) { allow = true; reason = 'org member'; }

            if (!allow && Array.isArray(cfg.temp_exemptions)) {
              const hit = cfg.temp_exemptions.find(x => String(x.login).toLowerCase() === String(actor).toLowerCase());
              if (hit?.until && nowIso <= new Date(hit.until).toISOString()) { allow = true; reason = 'temporary exemption'; }
            }

            core.setOutput('allow', allow ? 'true' : 'false');
            core.setOutput('reason', reason || '');
            core.setOutput('sign_phrase', process.env.SIGN_PHRASE);

      - name: Verify signer equals PR author (for comment-based sign)
        if: ${{ github.event_name == 'issue_comment' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const actor = context.payload.sender?.login;
            const commentBody = context.payload.comment?.body?.trim() || '';
            const expected = `${{ steps.allow.outputs.sign_phrase }}`.trim();
            if (commentBody !== expected) {
              core.setFailed(`Sign phrase must match exactly: "${expected}"`); return;
            }
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner, repo: context.repo.repo, pull_number: context.issue.number
            });
            if (!pr) { core.setFailed('PR not found for this comment'); return; }
            if (pr.user?.login !== actor) core.setFailed(`Signer (${actor}) must be the PR author (${pr.user?.login})`);

      - name: Allowlisted — skip CLA
        if: ${{ steps.allow.outputs.allow == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            core.info(`✅ CLA not required (allowlisted: ${{ steps.allow.outputs.reason }})`);

      - name: CLA Assistant Lite
        # run the assistant if (A) we must enforce CLA and the actor isn’t allowlisted
        # OR (B) we’re permissive but DCO is required for this actor.
        if: ${{ (steps.allow.outputs.policy_enforce == 'true' && steps.allow.outputs.allow != 'true') || steps.allow.outputs.need_dco == 'true' }}
        continue-on-error: true
        uses: contributor-assistant/github-action@v2.6.1
        with:
          path-to-signatures: ${{ inputs.signature_file_path }}
          path-to-document: ${{ inputs.cla_document_url }}
          branch: ${{ inputs.signature_branch }}
          remote-organization-name: ${{ github.repository_owner }}
          remote-repository-name: .github
          custom-pr-sign-comment: ${{ inputs.sign_comment_exact }}
          allowlist: 'dependabot[bot],github-actions[bot]'
        env:
          # For PR API (comments/status). Comes from base repo; safe in forks.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # For writing signatures into <org>/.github (cross-repo write from fork).
          PERSONAL_ACCESS_TOKEN: ${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}
          
      - name: Satisfy ruleset when assistant won’t run (publish license/cla success)
        # Write a success status only when:
        #   - license policy is permissive AND DCO is not required for this actor, OR
        #   - the actor was allowlisted (members/users/teams/temp/sign-by-comment)
        if: ${{ (steps.policy.outputs.enforce != 'true' && steps.allow.outputs.need_dco != 'true') || steps.allow.outputs.allow == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const sha   = context.payload.pull_request?.head?.sha || context.sha;

            const policyEnforce = '${{ steps.policy.outputs.enforce }}' === 'true';
            const allowed       = '${{ steps.allow.outputs.allow }}' === 'true';

            const state = 'success';
            const description = !policyEnforce
              ? 'CLA not required (permissive license)'
              : 'All contributors have signed the CLA';

            await github.rest.repos.createCommitStatus({
              owner, repo, sha,
              state,
              context: 'license/cla',
              description
            });

            core.info(`license/cla → ${state} (${description}) for ${owner}/${repo}@${sha}`);
