name: Reusable — CLA Check

on:
  workflow_call:
    inputs:
      cla_document_url:
        description: "URL to the CLA document"
        type: string
        default: https://raw.githubusercontent.com/${{ github.repository_owner }}/.github/main/CLA.md
      signature_file_path:
        description: "Path to signatures file in .github"
        type: string
        # You said signatures live at <org>/.github/signatures — this keeps the default under that dir.
        default: signatures/CLA.json
      signature_branch:
        description: "Branch in .github where signatures are stored"
        type: string
        default: main
      allowlist_branch:
        description: "Branch in .github with allowlist config"
        type: string
        default: cla-config
      allowlist_path:
        description: "YAML allowlist path in .github"
        type: string
        default: cla/allowlist.yml
      sign_comment_exact:
        description: 'Exact phrase required to sign via comment'
        type: string
        default: 'I have read the CLA Document and I hereby sign the CLA'
    secrets:
      CONTRIBUTOR_ASSISTANT_PAT:
        required: true

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write
  actions: read

concurrency:
  group: ${{ github.workflow }}-${{ github.run_id }}-${{ github.event.pull_request.number || github.event.issue.number || github.sha }}
  cancel-in-progress: false

jobs:
  cla:
    name: CLA gate
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      ORG: ${{ github.repository_owner }}
      REPO: ${{ github.event.repository.name }}
      GH_TOKEN: ${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}

    steps:
      - name: Preflight: verify token can reach .github and branch exists
        shell: bash
        env:
          ORG: ${{ github.repository_owner }}
          BRANCH: ${{ inputs.allowlist_branch }}
          PAT: ${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}
        run: |
          set -euo pipefail

          api() { curl -sS -w "\n%{http_code}" -H "Authorization: Bearer ${PAT}" -H "Accept: application/vnd.github+json" "$1"; }

          echo "Checking repo visibility and token access to ${ORG}/.github"
          read -r body code < <(api "https://api.github.com/repos/${ORG}/.github")
          echo "GET /repos/${ORG}/.github -> HTTP ${code}"
          if [ "${code}" = "403" ] || grep -qi 'resource not accessible' <<<"$body"; then
            echo "::error::403 from /repos: token lacks access or SSO not authorized for org '${ORG}'."
            exit 2
          elif [ "${code}" = "404" ]; then
            echo "::error::Repo '${ORG}/.github' not found (private? wrong org? different name?)."
            exit 2
          fi

          echo "Checking branch '${BRANCH}'"
          read -r b2 c2 < <(api "https://api.github.com/repos/${ORG}/.github/git/refs/heads/${BRANCH}")
          echo "GET /git/refs/heads/${BRANCH} -> HTTP ${c2}"
          if [ "${c2}" = "404" ]; then
            echo "::error::Branch '${BRANCH}' does not exist in ${ORG}/.github. Create it or change inputs.allowlist_branch."
            echo "Listing branches (first 100):"
            api "https://api.github.com/repos/${ORG}/.github/branches?per_page=100" | sed -n '1,200p'
            exit 3
          fi

          echo "Checking allowlist file path '${{ inputs.allowlist_path }}'"
          read -r b3 c3 < <(api "https://api.github.com/repos/${ORG}/.github/contents/${{ inputs.allowlist_path }}?ref=${BRANCH}")
          echo "GET /contents/${{ inputs.allowlist_path }}?ref=${BRANCH} -> HTTP ${c3}"
          if [ "${c3}" = "404" ]; then
            echo "::error::Allowlist not found at that path/branch."
            exit 4
          fi

          echo "Preflight OK."

      # Ensure we can read the allowlist from org .github repo
      - name: Checkout .github (allowlist)
        uses: actions/checkout@v4
        with:
          # Use the org that owns the current repo
          repository: ${{ github.repository_owner }}/.github
          # The branch where your allowlist lives (input default: cla-config)
          ref: ${{ inputs.allowlist_branch }}
          # IMPORTANT: use the forwarded PAT, not the default GITHUB_TOKEN
          token: ${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}
          # Put it in a separate folder to avoid mixing with the current repo
          path: .github-central
          fetch-depth: 1
          persist-credentials: false

      - name: Debug checkout
        shell: bash
        run: |
          set -euxo pipefail
          git --version
          echo "Workspace: $GITHUB_WORKSPACE"
          echo "Listing .github-central:"
          ls -la .github-central
          echo "Expected allowlist: .github-central/${{ inputs.allowlist_path }}"
          if [ ! -f ".github-central/${{ inputs.allowlist_path }}" ]; then
            echo "::error::Allowlist not found at .github-central/${{ inputs.allowlist_path }}"
            exit 2
          fi

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install YAML parser
        run: |
          cd ./.github-central
          npm init -y >/dev/null 2>&1
          npm i yaml >/dev/null 2>&1

      - name: Compute allowlisted/member
        id: allow
        uses: actions/github-script@v7
        env:
          ALLOWLIST_PATH: ${{ inputs.allowlist_path }}
          SIGN_PHRASE: ${{ inputs.sign_comment_exact }}
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const fs = require('fs');
            const path = require('path');
            const YAML = require(path.join(process.env.GITHUB_WORKSPACE, '.github-central', 'node_modules', 'yaml'));
            const allowPath = path.join(process.env.GITHUB_WORKSPACE, '.github-central', process.env.ALLOWLIST_PATH);
            let cfg = {};
            try {
              cfg = YAML.parse(fs.readFileSync(allowPath, 'utf8')) || {};
            } catch (e) {
              core.warning(`Allowlist not found/parse error at ${allowPath}: ${e}`);
            }
            const actor = context.payload.sender?.login;
            const org = context.repo.owner;
            const nowIso = new Date().toISOString();
            const asSet = xs => new Set((xs || []).map(s => String(s).toLowerCase()));
            const inSet = (set, s) => set.has(String(s || '').toLowerCase());
            let isMember = false;
            try { await github.rest.orgs.checkMembershipForUser({ org, username: actor }); isMember = true; } catch {}
            const botSet = asSet(cfg.bots), userSet = asSet(cfg.users);
            let allow = inSet(botSet, actor) || inSet(userSet, actor);
            let reason = allow ? 'explicit user/bot' : '';
            if (!allow && cfg.teams?.length) {
              try {
                const { data: teams } = await github.rest.teams.listForUserInOrg({ org, username: actor });
                const desired = asSet(cfg.teams.map(t => t.includes('/') ? t : `${org}/${t}`));
                allow = teams.some(t => desired.has(`${t.organization.login}/${t.slug}`.toLowerCase()));
                if (allow) reason = 'team';
              } catch (e) { core.warning(`Team lookup failed: ${e}`); }
            }
            if (!allow && cfg.org_members === true && isMember) { allow = true; reason = 'org member'; }
            if (!allow && Array.isArray(cfg.temp_exemptions)) {
              const hit = cfg.temp_exemptions.find(x => String(x.login).toLowerCase() === String(actor).toLowerCase());
              if (hit?.until && nowIso <= new Date(hit.until).toISOString()) { allow = true; reason = 'temporary exemption'; }
            }
            core.setOutput('allow', allow ? 'true' : 'false');
            core.setOutput('reason', reason || '');
            core.setOutput('sign_phrase', process.env.SIGN_PHRASE);

      - name: Verify signer equals PR author (for comment-based sign)
        if: ${{ github.event_name == 'issue_comment' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const actor = context.payload.sender?.login;
            const commentBody = context.payload.comment?.body?.trim() || '';
            const expected = `${{ steps.allow.outputs.sign_phrase }}`.trim();
            if (commentBody !== expected) {
              core.setFailed(`Sign phrase must match exactly: "${expected}"`); return;
            }
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner, repo: context.repo.repo, pull_number: context.issue.number
            });
            if (!pr) { core.setFailed('PR not found for this comment'); return; }
            if (pr.user?.login !== actor) core.setFailed(`Signer (${actor}) must be the PR author (${pr.user?.login})`);

      - name: Allowlisted — skip CLA
        if: ${{ steps.allow.outputs.allow == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
        # (comment omitted for brevity; keeping logs clean)
          script: |
            core.info(`✅ CLA not required (allowlisted: ${{ steps.allow.outputs.reason }})`);

      - name: CLA Assistant Lite
        if: ${{ steps.allow.outputs.allow != 'true' }}
        uses: contributor-assistant/github-action@v2.6.1
        with:
          path-to-signatures: ${{ inputs.signature_file_path }}
          path-to-document: ${{ inputs.cla_document_url }}
          branch: ${{ inputs.signature_branch }}
          remote-organization-name: ${{ github.repository_owner }}
          remote-repository-name: .github
          custom-pr-sign-comment: ${{ inputs.sign_comment_exact }}
          allowlist: 'dependabot[bot],github-actions[bot]'
        env:
          GITHUB_TOKEN: ${{ env.GH_TOKEN }}
