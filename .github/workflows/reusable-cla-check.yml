name: Reusable — CLA Check

on:
  workflow_call:
    inputs:
      cla_document_url:
        description: "URL to the CLA document"
        type: string
        default: https://raw.githubusercontent.com/${{ github.repository_owner }}/.github/main/CLA.md
      signature_file_path:
        description: "Path to signatures file in .github"
        type: string
        default: signatures/CLA.json
      signature_branch:
        description: "Branch in .github where signatures are stored"
        type: string
        default: main
      allowlist_branch:
        description: "Branch in .github with allowlist config"
        type: string
        default: cla-config
      allowlist_path:
        description: "YAML allowlist path in .github"
        type: string
        default: cla/allowlist.yml
      sign_comment_exact:
        description: 'Exact phrase required to sign via comment'
        type: string
        default: 'I have read the CLA Document and I hereby sign the CLA'
    secrets:
      CONTRIBUTOR_ASSISTANT_PAT:
        required: true

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write
  actions: read

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

jobs:
  cla:
    name: CLA gate
    # Debounce: always run for PR events; for issue_comment only if it contains the exact sign phrase
    if: >
      ${{
        github.event_name == 'pull_request_target' ||
        (github.event_name == 'issue_comment' &&
         github.event.issue.pull_request &&
         contains(github.event.comment.body, inputs.sign_comment_exact))
      }}
    runs-on: ubuntu-latest
    timeout-minutes: 10
    env:
      ORG: ${{ github.repository_owner }}
      REPO: ${{ github.event.repository.name }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      # Preflight clarifies whether the PAT can access org .github and the allowlist branch/path.
      - name: "Preflight: verify token can reach .github and branch exists"
        shell: bash
        env:
          ORG: ${{ github.repository_owner }}
          BRANCH: ${{ inputs.allowlist_branch }}
          PAT: ${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}
        run: |
          set -euo pipefail
          api() { curl -sS -H "Authorization: Bearer ${PAT}" -H "Accept: application/vnd.github+json" "$1"; }
          api_code() { curl -sS -o /dev/null -w "%{http_code}" -H "Authorization: Bearer ${PAT}" -H "Accept: application/vnd.github+json" "$1"; }
          api_body_code() { 
            local url="$1"
            local out="$(mktemp)"
            local code
            code="$(curl -sS -o "$out" -w "%{http_code}" -H "Authorization: Bearer ${PAT}" -H "Accept: application/vnd.github+json" "$url")"
            printf "%s\n" "$out"
            printf "%s\n" "$code"
          }

          echo "Checking repo visibility and token access to ${ORG}/.github"
          out_and_code=($(api_body_code "https://api.github.com/repos/${ORG}/.github"))
          OUT_FILE="${out_and_code[0]}"
          CODE="${out_and_code[1]}"
          echo "GET /repos/${ORG}/.github -> HTTP ${CODE}"
          if [ "${CODE}" = "403" ]; then
            echo "::error::403 from /repos: token lacks access or SSO not authorized for org '${ORG}'."
            cat "${OUT_FILE}" || true
            exit 2
          elif [ "${CODE}" = "404" ]; then
            echo "::error::Repo '${ORG}/.github' not found (private? wrong org? different name?)."
            exit 2
          fi

          echo "Checking branch '${BRANCH}'"
          CODE="$(api_code "https://api.github.com/repos/${ORG}/.github/git/refs/heads/${BRANCH}")"
          echo "GET /git/refs/heads/${BRANCH} -> HTTP ${CODE}"
          if [ "${CODE}" = "404" ]; then
            echo "::error::Branch '${BRANCH}' does not exist in ${ORG}/.github. Create it or change inputs.allowlist_branch."
            curl -sS -H "Authorization: Bearer ${PAT}" -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${ORG}/.github/branches?per_page=100" | sed -n '1,200p' || true
            exit 3
          fi

          echo "Checking allowlist file path '${{ inputs.allowlist_path }}'"
          CODE="$(api_code "https://api.github.com/repos/${ORG}/.github/contents/${{ inputs.allowlist_path }}?ref=${BRANCH}")"
          echo "GET /contents/${{ inputs.allowlist_path }}?ref=${BRANCH} -> HTTP ${CODE}"
          if [ "${CODE}" = "404" ]; then
            echo "::error::Allowlist not found at that path/branch."
            exit 4
          fi

          echo "Preflight OK."

      - name: Resolve GH_TOKEN (prefer PAT, fallback to GITHUB_TOKEN)
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}" ]; then
            echo "GH_TOKEN=${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}" >> "$GITHUB_ENV"
            echo "Using CONTRIBUTOR_ASSISTANT_PAT for GitHub API calls."
          else
            echo "GH_TOKEN=${{ secrets.GITHUB_TOKEN }}" >> "$GITHUB_ENV"
            echo "Falling back to GITHUB_TOKEN for GitHub API calls."
          fi

      # Trusted checkout — ONLY the org's .github repo to read allowlist
      - name: Checkout .github (allowlist)
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/.github
          ref: ${{ inputs.allowlist_branch }}
          token: ${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}
          path: .github-central
          fetch-depth: 1
          persist-credentials: false

      - name: Debug checkout
        shell: bash
        run: |
          set -euxo pipefail
          git --version
          echo "Workspace: $GITHUB_WORKSPACE"
          echo "Listing .github-central:"
          ls -la .github-central
          echo "Expected allowlist: .github-central/${{ inputs.allowlist_path }}"
          if [ ! -f ".github-central/${{ inputs.allowlist_path }}" ]; then
            echo "::error::Allowlist not found at .github-central/${{ inputs.allowlist_path }}"
            exit 2
          fi

      - name: Install yq (YAML CLI)
        shell: bash
        run: |
          set -euo pipefail
          YQ_VER=v4.44.3
          curl -sSL -o /usr/local/bin/yq "https://github.com/mikefarah/yq/releases/download/${YQ_VER}/yq_linux_amd64"
          chmod +x /usr/local/bin/yq
          yq --version

      - name: Compute allowlisted/member
        id: allow
        uses: actions/github-script@v7
        env:
          ALLOWLIST_PATH: ${{ inputs.allowlist_path }}
          SIGN_PHRASE: ${{ inputs.sign_comment_exact }}
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const { execSync } = require('node:child_process');
            const path = require('node:path');

            const allowPath = path.join(process.env.GITHUB_WORKSPACE, '.github-central', process.env.ALLOWLIST_PATH);
            let cfg = {};
            try {
              const json = execSync(`yq -o=json '${allowPath}'`, { stdio: ['ignore','pipe','pipe'] }).toString();
              cfg = JSON.parse(json) || {};
            } catch (e) {
              core.warning(`Allowlist not found/parse error at ${allowPath}: ${e}`);
            }

            const actor = context.payload.sender?.login;
            const org = context.repo.owner;
            const nowIso = new Date().toISOString();
            const asSet = xs => new Set((xs || []).map(s => String(s).toLowerCase()));
            const inSet = (set, s) => set.has(String(s || '').toLowerCase());

            let isMember = false;
            try { await github.rest.orgs.checkMembershipForUser({ org, username: actor }); isMember = true; } catch {}

            const botSet = asSet(cfg.bots), userSet = asSet(cfg.users);
            let allow = inSet(botSet, actor) || inSet(userSet, actor);
            let reason = allow ? 'explicit user/bot' : '';

            // ---- Repo policy: decide if this repo requires CLA at all (defaults to permissive unless configured) ----
            function repoRequiresCLA(cfg, ownerName, repoName) {
              // Global default: enforce only if explicitly true
              let enforce = cfg?.require_cla === true;
      
              // Fine-grained map wins
              if (cfg?.repos && Object.prototype.hasOwnProperty.call(cfg.repos, repoName)) {
                const v = cfg.repos[repoName]?.require_cla;
                if (typeof v === 'boolean') enforce = v;
              } else {
                // Fallback to simple lists
                if (Array.isArray(cfg?.non_permissive_repos) && cfg.non_permissive_repos.includes(repoName)) enforce = true;
                if (Array.isArray(cfg?.permissive_repos) && cfg.permissive_repos.includes(repoName)) enforce = false;
              }
              return enforce;
            }
      
            const repoName = context.repo.repo;
            const enforce = repoRequiresCLA(cfg, org, repoName);
      
            // If this repo is permissive, expose outputs and exit early
            if (!enforce) {
              core.setOutput('policy_enforce', 'false');
              core.setOutput('allow', 'true');
              core.setOutput('reason', `permissive_repo:${repoName}`);
              return;
            }
      
            // Mark that enforcement is active; continue with allowlist checks below
            core.setOutput('policy_enforce', 'true');

            if (!allow && Array.isArray(cfg.teams) && cfg.teams.length) {
              try {
                const { data: teams } = await github.rest.teams.listForUserInOrg({ org, username: actor });
                const desired = asSet(cfg.teams.map(t => t.includes('/') ? t : `${org}/${t}`));
                allow = teams.some(t => desired.has(`${t.organization.login}/${t.slug}`.toLowerCase()));
                if (allow) reason = 'team';
              } catch (e) { core.warning(`Team lookup failed: ${e}`); }
            }

            if (!allow && cfg.org_members === true && isMember) { allow = true; reason = 'org member'; }

            if (!allow && Array.isArray(cfg.temp_exemptions)) {
              const hit = cfg.temp_exemptions.find(x => String(x.login).toLowerCase() === String(actor).toLowerCase());
              if (hit?.until && nowIso <= new Date(hit.until).toISOString()) { allow = true; reason = 'temporary exemption'; }
            }

            core.setOutput('allow', allow ? 'true' : 'false');
            core.setOutput('reason', reason || '');
            core.setOutput('sign_phrase', process.env.SIGN_PHRASE);

      - name: Verify signer equals PR author (for comment-based sign)
        if: ${{ github.event_name == 'issue_comment' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            const actor = context.payload.sender?.login;
            const commentBody = context.payload.comment?.body?.trim() || '';
            const expected = `${{ steps.allow.outputs.sign_phrase }}`.trim();
            if (commentBody !== expected) {
              core.setFailed(`Sign phrase must match exactly: "${expected}"`); return;
            }
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner, repo: context.repo.repo, pull_number: context.issue.number
            });
            if (!pr) { core.setFailed('PR not found for this comment'); return; }
            if (pr.user?.login !== actor) core.setFailed(`Signer (${actor}) must be the PR author (${pr.user?.login})`);

      - name: Allowlisted — skip CLA
        if: ${{ steps.allow.outputs.allow == 'true' }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ env.GH_TOKEN }}
          script: |
            core.info(`✅ CLA not required (allowlisted: ${{ steps.allow.outputs.reason }})`);

      - name: CLA Assistant Lite
        if: ${{ steps.allow.outputs.policy_enforce == 'true' && steps.allow.outputs.allow != 'true' }}
        uses: contributor-assistant/github-action@v2.6.1
        with:
          path-to-signatures: ${{ inputs.signature_file_path }}
          path-to-document: ${{ inputs.cla_document_url }}
          branch: ${{ inputs.signature_branch }}
          remote-organization-name: ${{ github.repository_owner }}
          remote-repository-name: .github
          custom-pr-sign-comment: ${{ inputs.sign_comment_exact }}
          allowlist: 'dependabot[bot],github-actions[bot]'
        env:
          # For PR API (comments/status). Comes from base repo; safe in forks.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # For writing signatures into <org>/.github (cross-repo write from fork).
          PERSONAL_ACCESS_TOKEN: ${{ secrets.CONTRIBUTOR_ASSISTANT_PAT }}
